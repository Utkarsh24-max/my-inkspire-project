<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>InkSpire: Sketch to Color</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary-dark': '#1e293b',
                        'secondary-dark': '#334155',
                        'accent': '#6366f1',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    <style>
        /* Custom styles for the canvas */
        #sketchCanvas {
            cursor: crosshair;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        /* Custom scrollbar for better look in dark mode */
        body::-webkit-scrollbar {
            width: 8px;
        }
        body::-webkit-scrollbar-thumb {
            background-color: #6366f1;
            border-radius: 20px;
        }
    </style>
</head>

<body class="bg-primary-dark min-h-screen text-white font-sans flex items-center justify-center p-4">

    <div class="w-full max-w-6xl mx-auto p-6 lg:p-10 bg-secondary-dark rounded-xl shadow-2xl space-y-8">

        <!-- Header -->
        <header class="text-center">
            <h1 class="text-4xl font-extrabold text-accent">ðŸŽ¨ InkSpire: Sketch to Color âœ¨</h1>
            <p class="mt-2 text-gray-300">Draw your sketch and let the Generative Model color it!</p>
        </header>

        <!-- Main Content Grid -->
        <div class="grid lg:grid-cols-2 gap-8">

            <!-- 1. Sketch Input Area -->
            <div class="bg-primary-dark p-4 rounded-lg shadow-inner">
                <h2 class="text-xl font-semibold mb-3 text-gray-200">Your Sketch (Black on White)</h2>
                <canvas id="sketchCanvas" class="w-full aspect-square border-4 border-gray-600 rounded-lg bg-white"></canvas>

                <!-- Controls -->
                <div class="mt-4 p-4 bg-secondary-dark rounded-lg flex flex-wrap items-center justify-center gap-4 shadow-md">
                    <!-- Brush Color -->
                    <div class="flex items-center space-x-2">
                        <label for="brushColor" class="text-gray-300">Line Color:</label>
                        <input type="color" id="brushColor" value="#000000" class="h-8 w-8 rounded-full border-none p-0 cursor-pointer">
                    </div>

                    <!-- Brush Size -->
                    <div class="flex items-center space-x-2 w-32">
                        <label for="brushSize" class="text-gray-300 whitespace-nowrap">Size:</label>
                        <input type="range" id="brushSize" min="5" max="30" value="15" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer range-lg">
                    </div>

                    <!-- Action Buttons -->
                    <button id="clearButton" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg transition duration-200 shadow-lg">Clear</button>
                    <button id="undoButton" class="px-4 py-2 bg-yellow-600 hover:bg-yellow-700 text-white font-bold rounded-lg transition duration-200 shadow-lg">Undo</button>
                </div>
            </div>

            <!-- 2. Output Display Area -->
            <div class="bg-primary-dark p-4 rounded-lg shadow-inner flex flex-col items-center justify-start">
                <h2 class="text-xl font-semibold mb-3 text-gray-200">Generated Color Image</h2>
                <img id="outputImage" class="w-full aspect-square border-4 border-gray-600 rounded-lg object-contain bg-gray-700 p-2" 
                     src="https://placehold.co/256x256/334155/e2e8f0?text=Output+Image" 
                     alt="Generated colored image">

                <!-- Generate Button -->
                <button id="generateButton" class="mt-6 px-8 py-3 bg-accent hover:bg-indigo-600 text-white text-xl font-extrabold rounded-xl transition duration-300 shadow-xl transform hover:scale-[1.02] active:scale-95 disabled:bg-gray-500 disabled:cursor-not-allowed">
                    Generate Color Image
                </button>

                <!-- Status Message -->
                <div id="statusMessage" class="mt-4 text-center text-sm text-gray-400 min-h-[1.25rem]"></div>
            </div>
        </div>

    </div>

    <script>
        const canvas = document.getElementById('sketchCanvas');
        const ctx = canvas.getContext('2d');
        const brushColorInput = document.getElementById('brushColor');
        const brushSizeInput = document.getElementById('brushSize');
        const clearButton = document.getElementById('clearButton');
        const undoButton = document.getElementById('undoButton');
        const generateButton = document.getElementById('generateButton');
        const outputImage = document.getElementById('outputImage');
        const statusMessage = document.getElementById('statusMessage');

        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let history = [];
        let historyIndex = -1;

        // Set canvas dimensions to be square and high resolution for drawing quality
        const CANVAS_SIZE = 512;
        canvas.width = CANVAS_SIZE;
        canvas.height = CANVAS_SIZE;

        // Function to initialize or clear the canvas with a white background
        function initializeCanvas() {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // After clearing, reset history
            history = [];
            historyIndex = -1;
            saveState();
        }

        function saveState() {
            // Only save if the current index is the end of history
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            history.push(canvas.toDataURL());
            historyIndex++;
        }

        function restoreState(index) {
            if (index >= 0 && index < history.length) {
                const img = new Image();
                img.onload = function() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                img.src = history[index];
                historyIndex = index;
            }
        }

        // --- Drawing Functions ---
        function draw(e) {
            if (!isDrawing) return;

            // Get coordinates relative to canvas
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;

            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;

            ctx.strokeStyle = brushColorInput.value;
            ctx.lineWidth = brushSizeInput.value;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);
            ctx.stroke();

            [lastX, lastY] = [x, y];
        }

        function startDrawing(e) {
            // Prevent scrolling on touch devices
            e.preventDefault(); 
            isDrawing = true;
            
            // Capture initial position
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            
            [lastX, lastY] = [(clientX - rect.left) * scaleX, (clientY - rect.top) * scaleY];
            draw(e); // Draw a single point on click/tap
        }

        function stopDrawing() {
            if (isDrawing) {
                isDrawing = false;
                saveState(); // Save state only after a complete stroke
            }
        }

        // --- Event Listeners ---

        // Mouse Events
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        window.addEventListener('mouseup', stopDrawing);

        // Touch Events (for mobile responsiveness)
        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', draw);
        window.addEventListener('touchend', stopDrawing);
        window.addEventListener('touchcancel', stopDrawing);


        clearButton.addEventListener('click', initializeCanvas);
        undoButton.addEventListener('click', () => {
            if (historyIndex > 0) {
                restoreState(historyIndex - 1);
            }
        });

        // --- Model Interaction ---
        generateButton.addEventListener('click', async () => {
            // 1. Get the canvas image data as a PNG Data URL
            const imageDataURL = canvas.toDataURL('image/png');

            // Set UI state for loading
            generateButton.disabled = true;
            generateButton.textContent = 'Generating... Please wait.';
            statusMessage.innerHTML = '<span class="text-accent">Sending sketch to the model...</span>';
            outputImage.classList.add('animate-pulse');
            outputImage.src = 'https://placehold.co/256x256/334155/e2e8f0?text=Loading...';

            try {
                // 2. Send the data to the Flask endpoint
                const response = await fetch('/process_sketch', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ image: imageDataURL }),
                });

                const data = await response.json();

                if (data.error) {
                    statusMessage.innerHTML = `<span class="text-red-500">Error: ${data.error.substring(0, 100)}...</span>`;
                    outputImage.src = 'https://placehold.co/256x256/ef4444/ffffff?text=ERROR';
                } else if (data.coloredImage) {
                    // 3. Display the result
                    outputImage.src = `data:image/png;base64,${data.coloredImage}`;
                    statusMessage.innerHTML = '<span class="text-green-500">Success!</span>';
                } else {
                    statusMessage.innerHTML = '<span class="text-red-500">Unknown API response.</span>';
                }

            } catch (error) {
                statusMessage.innerHTML = `<span class="text-red-500">Network Error: ${error.message}</span>`;
                outputImage.src = 'https://placehold.co/256x256/ef4444/ffffff?text=ERROR';
            } finally {
                // Reset UI state
                generateButton.disabled = false;
                generateButton.textContent = 'Generate Color Image';
                outputImage.classList.remove('animate-pulse');
            }
        });

        // Initialize the canvas when the script runs
        initializeCanvas();
    </script>
</body>
</html>
